package com.srikanth.security;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



/**
 * Security Principles are Integrity, Confidentiality, Authentication,
 * Authorization and Trust. There are various security providers such as: Bouncy
 * Castle, keyczar, jasypt, verisign.
 * 
 * Message Digests are coupled with message authentication codes (MAC). A
 * message digest is a function that ensures the integrity of a message.
 * 
 * Note: Message Digests may ensure integrity of a message but they can't be
 * be used to ensure the confidentiality of the message. For that, we need to 
 * use the private key cryptography to exchange private messages.
 * 
 * Message digests take a message as input and generate a block of bits, usually
 * several hundred bits long, that represents the finger print of the message. A
 * small change in the message (say, by an interloper or eavesdropper) creates a
 * noticeable change in the finger print. The message-digest function is a
 * one-way function. It is a simple matter to generate the finger print from the
 * message, but quite difficult to generate a message that matches a given
 * finger print.
 * 
 * Message digests can be weak or strong. A checksum -- which is the XOR
 * (exclusive OR '^' means "this or that, but not both!". of all the bytes of a
 * message -- is an example of a weak message-digest function. It is easy to
 * modify one byte to generate any desired checksum finger print.
 * 
 * Most strong functions use hashing. A 1-bit change in the message leads to a
 * massive change in the finger print (ideally, 50 percent of the finger print
 * bits change).
 * 
 * JDK7 supports the following message digest hashing algorithms: 
 * MD2 & MD5: 128 bit algorithm. 
 * SHA-1 (Secure Hash Algorithm): 160 bit algorithm. 
 * SHA-256 & SHA 384 & SHA-512: which offer longer finger print sizes 
 * of 256, 384, and 512 bits respectively.
 * 
 * Note: MD5 and SHA-1 are the most used algorithms. MD5 is generally faster
 * than SHA. However SHA is more secure than MD5.
 *  
 * to know more about hashing:
 * types: http://en.wikipedia.org/wiki/List_of_hash_functions
 * 
 * ***** Message Authentication Code (MAC) ************************* If a key is
 * used as part of the message-digest generation, the algorithm is known as a
 * message-authentication code.
 * 
 * JDK 1.4 supports the HMAC/SHA-1 and HMAC/MD5 message-authentication code
 * algorithms. JDK7 supports MD5, SHA1, SHA256 algorithms.
 * 
 * Note: Note that the key generation takes a long time because the code is
 * generating excellent quality pseudo-random numbers using the timing of thread
 * behavior. Once the first number is generated, the others take much less time.
 * 
 * Why do we need MAC? A message digest algorithm takes a single input -- a
 * message -- and produces a "message digest" (aka hash) which allows you to
 * verify the integrity of the message: Any change to the message will (ideally)
 * result in a different hash being generated. An attacker that can replace the
 * message and digest is fully capable of replacing the message and digest with
 * a new valid pair.
 * 
 * A MAC algorithm takes two inputs -- a message and a secret key -- and
 * produces a MAC which allows you to verify the integrity and the authenticity
 * of the message: Any change to the message or the secret key will (ideally)
 * result in a different MAC being generated. Nobody without access to the
 * secret should be able to generate a MAC calculation that verifies; in other
 * words a MAC can be used to check that the MAC was generated by a party that
 * has access to the secret key. A HMAC algorithm is simply a specific type of
 * MAC algorithm that uses a hash algorithm internally (rather than, for
 * example, an encryption algorithm) to generate the MAC.
 * 
 * @author Srikanth
 * 
 */
public class MessageDigestDemo {
	
	static Logger logger = LoggerFactory.getLogger(MessageDigestDemo.class);
	
	public static final String MD2 = "MD2";
	public static final String MD5 = "MD5";
	public static final String MD6 = "MD6";
	public static final String SHA1 = "SHA1";
	public static final String SHA256 = "SHA256";
	public static final String SHA384 = "SHA384";
	public static final String SHA512 = "SHA512";
	
	public static final String HMAC_MD5 = "HmacMD5";
	public static final String HMAC_SHA1 = "HmacSHA1";
	public static final String HMAC_SHA256 = "HmacSHA256";
	public static final String HMAC_SHA384 = "HmacSHA384";
	public static final String HMAC_SHA512 = "HmacSHA512";
	
	/**
	 * Supported Message Digest Hashing Algorithm Types:
	 * In JDK7: MD2, MD5, SHA1, SHA256, SHA384, SHA512.
	 * @param message
	 * @param type
	 */
	public static void createMessageDigest(String message, String type) {
		try {
			byte[] plainText = message.getBytes("UTF8");
			MessageDigest messageDigest = MessageDigest.getInstance(type);
			logger.info("Provider Info: " + messageDigest.getProvider().getInfo());
			logger.info("Plain Text: " + plainText + " and Message Digest: " + new String(messageDigest.digest(), "UTF8"));
			
		} catch (UnsupportedEncodingException | NoSuchAlgorithmException e) {
			logger.error("Error Occurred: ", e);
		}
	}
	/**
	 * Supported Message Authentication Code Algorithm Types:
	 * In JDK7: HmacMD5, HmacSHA1, HmacSHA256, HmacSHA384, HmacSHA512.
	 * @param message
	 * @param hashType
	 */
	public static void createMessageAuthenticationCode(String message, String type) {
		try {
			byte[] plainText = message.getBytes("UTF8");
			logger.info("Start generating key..");
			KeyGenerator keyGenerator = KeyGenerator.getInstance(type);
			SecretKey secretKey = keyGenerator.generateKey(); 
			logger.info("Key generation completed..");
			Mac mac = Mac.getInstance(type);
			mac.init(secretKey);
			mac.update(plainText);
			logger.info("Provider Info: " + mac.getProvider().getInfo());
			logger.info("Plain Text: " + plainText + " and MAC: " + new String(mac.doFinal(), "UTF8"));
			
		} catch (UnsupportedEncodingException | NoSuchAlgorithmException | InvalidKeyException e) {
			logger.error("Error Occurred: ", e);
		}
	}
}
